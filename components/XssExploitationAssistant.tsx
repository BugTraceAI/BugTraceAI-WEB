// version 0.0.37
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { ChatMessage, Vulnerability } from '../types.ts';
import { ChatMessage as ChatContextMessage } from '../contexts/ChatContext';
import { BeakerIcon, PaperAirplaneIcon } from './Icons.tsx';
import { startExploitChat, continueExploitChat } from '../services/Service.ts';
import { useApiOptions } from '../hooks/useApiOptions.ts';
import { ChatBubble } from './ChatBubble.tsx';
import { ChatLayout } from './ChatLayout.tsx';

// Helper to convert legacy ChatMessage to ChatContext format
const convertToContextMessage = (msg: ChatMessage, index: number): ChatContextMessage => ({
  id: `legacy-${index}`,
  role: msg.role === 'model' ? 'assistant' : msg.role === 'user' ? 'user' : 'error',
  content: msg.content,
  created_at: new Date().toISOString(),
});

interface XssExploitationAssistantProps {
  exploitContext: {
    vulnerability: Vulnerability;
    targetUrl?: string;
  } | null;
  onShowApiKeyWarning: () => void;
}

export const XssExploitationAssistant: React.FC<XssExploitationAssistantProps> = ({ exploitContext, onShowApiKeyWarning }) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [userInput, setUserInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { apiOptions, isApiKeySet } = useApiOptions();

  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const isResponding = useRef(false); // Lock to prevent concurrent requests
  
  // Effect to start a new chat when the context changes
  useEffect(() => {
    if (!exploitContext) {
      return;
    }

    const startChat = async () => {
      if (isResponding.current) return;
      if (!isApiKeySet) {
        onShowApiKeyWarning();
        setError("API Key is not configured. Please set it in the settings.");
        return;
      }
      setError(null);
      setIsLoading(true);
      setMessages([]);
      isResponding.current = true;

      try {
        const firstMessage = await startExploitChat(exploitContext, apiOptions!);
        setMessages([{ role: 'model', content: firstMessage }]);
      } catch (e: any) {
        if (e.message !== "Request cancelled.") {
            setError(e.message || "Failed to start chat session.");
        }
      } finally {
        setIsLoading(false);
        isResponding.current = false;
      }
    };
    
    startChat();
  }, [exploitContext, apiOptions, isApiKeySet, onShowApiKeyWarning]);

  const handleSendMessage = useCallback(async () => {
    if (!isApiKeySet) {
        onShowApiKeyWarning();
        return;
    }
    if (!userInput.trim() || isLoading || isResponding.current) return;
    
    isResponding.current = true; // Acquire lock immediately
    setError(null);

    const newUserMessage: ChatMessage = { role: 'user', content: userInput };
    const historyForApi = [...messages];
    const userInputForApi = userInput;

    setMessages(prev => [...prev, newUserMessage, { role: 'model', content: '...', isLoading: true }]);
    setUserInput('');
    setIsLoading(true);
    
    try {
        const responseContent = await continueExploitChat(historyForApi, userInputForApi, apiOptions!);
        const newModelMessage: ChatMessage = { role: 'model', content: responseContent };
        setMessages(prev => [...prev.slice(0, -1), newModelMessage]);
    } catch (e: any) {
        setMessages(prev => prev.slice(0, -1)); // Remove loading bubble on error/cancel
        if (e.message !== "Request cancelled.") {
            setError(e.message || "Failed to get a response.");
        }
    } finally {
        setIsLoading(false);
        isResponding.current = false;
    }
  }, [userInput, isLoading, messages, apiOptions, isApiKeySet, onShowApiKeyWarning]);

  const handleFormSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    handleSendMessage();
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if ((e.ctrlKey || e.altKey) && e.key === 'Enter') {
      e.preventDefault();
      handleSendMessage();
    }
  };

  // Auto-resize textarea
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto'; // Reset height
      const scrollHeight = textareaRef.current.scrollHeight;
      textareaRef.current.style.height = `${scrollHeight}px`;
    }
  }, [userInput]);


  if (!exploitContext) {
    return (
      <div className="bg-purple-medium/50 backdrop-blur-xl p-8 rounded-xl border-0 shadow-xl text-center">
        <BeakerIcon className="h-12 w-12 mx-auto text-coral mb-4" />
        <h3 className="text-xl font-bold text-white mb-2">Exploit Assistant</h3>
        <p className="text-purple-gray">
          To begin, find a potential XSS vulnerability and click "Analyze Exploit Path".
        </p>
      </div>
    );
  }

  const headerContent = (
    <>
      <div className="flex items-center gap-3">
          <BeakerIcon className="h-6 w-6 text-coral" />
          <h3 className="text-xl font-bold text-white">Exploit Assistant</h3>
      </div>
      <p className="text-xs text-muted mt-1">Chatting about: <span className="font-semibold text-purple-300">{exploitContext.vulnerability.vulnerability}</span></p>
    </>
  );
  
  const footerContent = (
      <>
      {error && <div className="p-2 mb-2 text-xs text-center bg-red-900/50 border border-red-700 text-red-200 rounded-lg font-mono flex-shrink-0">{error}</div>}
      <form onSubmit={handleFormSubmit} className="relative flex items-end gap-2">
         <textarea
          ref={textareaRef}
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={isLoading ? 'AI is thinking...' : 'Ask a follow-up question... (Ctrl/Alt+Enter to send)'}
          disabled={isLoading}
          className="w-full pl-4 pr-4 py-3 bg-purple-medium/60 border-2 border-0 rounded-lg text-white placeholder-text-tertiary focus:ring-2 focus:ring-purple-500 focus:border-purple-500 focus:outline-none transition-all duration-300 resize-none overflow-y-hidden"
          rows={1}
          style={{ maxHeight: '150px' }}
        />
        <button
          type="submit"
          disabled={isLoading || !userInput.trim()}
          className="flex-shrink-0 p-3 rounded-lg bg-purple-600 text-white hover:bg-purple-500 disabled:bg-gray-600 disabled:cursor-not-allowed transition-colors"
          aria-label="Send message"
          title="Send message"
        >
          <PaperAirplaneIcon className="h-5 w-5" />
        </button>
      </form>
      </>
  );

  return (
    <ChatLayout header={headerContent} footer={footerContent}>
      {isLoading && messages.length === 0 ? (
        <div className="text-center text-purple-gray animate-pulse">
          <p>AI is analyzing the exploit path...</p>
        </div>
      ) : (
        messages.map((msg, index) => <ChatBubble key={index} message={convertToContextMessage(msg, index)} isLoading={msg.isLoading} />)
      )}
    </ChatLayout>
  );
};